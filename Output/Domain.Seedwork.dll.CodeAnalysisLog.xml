<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="c:\program files\microsoft visual studio 10.0\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="10.0">
 <Namespaces>
  <Namespace Name="Domain.Seedwork">
   <Messages>
    <Message TypeName="AvoidNamespacesWithFewTypes" Category="Microsoft.Design" CheckId="CA1020" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
     <Issue Certainty="50" Level="Warning">考虑将“Domain.Seedwork”中定义的类型与另一个命名空间合并。</Issue>
    </Message>
   </Messages>
  </Namespace>
 </Namespaces>
 <Targets>
  <Target Name="E:\MyCode\MyCommonLibrary\Output\Domain.Seedwork.dll">
   <Modules>
    <Module Name="domain.seedwork.dll">
     <Namespaces>
      <Namespace Name="Domain.Seedwork.DomainModel">
       <Types>
        <Type Name="DomainException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementISerializableCorrectly" Category="Microsoft.Usage" CheckId="CA2240" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Certainty="60" Level="Error">向类型 'DomainException' 中添加对 GetObjectData 的实现。</Issue>
          </Message>
          <Message TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DomainException': protected DomainException(SerializationInfo, StreamingContext)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DomainException': public DomainException(String, Exception)。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="DuplicatedNameException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DuplicatedNameException': protected DuplicatedNameException(SerializationInfo, StreamingContext)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DuplicatedNameException': public DuplicatedNameException()。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DuplicatedNameException': public DuplicatedNameException(String)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'DuplicatedNameException': public DuplicatedNameException(String, Exception)。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="EventPublisher" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="StaticHolderTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1053" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Name="CSharp2_0" Certainty="90" Level="Error">由于类型 'EventPublisher' 仅包含“static”成员，因此将它标记为“static”可阻止编译器添加默认公共构造函数。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Publish(Domain.Seedwork.DomainModel.IDomainEvent)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="EventPublisher.cs" Line="16">在外部可见方法 'EventPublisher.Publish(IDomainEvent)' 中，请在使用参数“evnt”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EventSubscriberMappingStore" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetSubscriberTypesList(System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="EventSubscriberMappingStore.cs" Line="53">更改 'EventSubscriberMappingStore.GetSubscriberTypesList(Type)' 中的 'List&lt;Type&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ResolveEventSubscriberTypeMappings(System.Reflection.Assembly)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="EventSubscriberMappingStore.cs" Line="32">在外部可见方法 'EventSubscriberMappingStore.ResolveEventSubscriberTypeMappings(Assembly)' 中，请在使用参数“assembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IRole`1" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AvoidEmptyInterfaces" Category="Microsoft.Design" CheckId="CA1040" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Warning">定义一个自定义特性来替换 'IRole&lt;TRoleId&gt;'。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="IValidationError" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetErrors()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">如果可行，请将 'IValidationError.GetErrors()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IValueObject" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetAtomicValues()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">如果可行，请将 'IValueObject.GetAtomicValues()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MannualAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Certainty="75" Level="Warning">如有可能，请密封 'MannualAttribute'。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="Object`1" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AbstractTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1012" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="CriticalWarning">将 'Object&lt;TObjectId&gt;' 中所有公共构造函数的可访问性改为 protected。</Issue>
          </Message>
          <Message Id="Object" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="95" Level="Error">重命名类型 'Object&lt;TObjectId&gt;'，使它不再与保留的语言关键字“Object”冲突。如果使用保留的关键字作为类型的名称，则会使其他语言的使用者很难使用该类型。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ObjectNotExistException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'ObjectNotExistException': protected ObjectNotExistException(SerializationInfo, StreamingContext)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'ObjectNotExistException': public ObjectNotExistException()。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'ObjectNotExistException': public ObjectNotExistException(String)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'ObjectNotExistException': public ObjectNotExistException(String, Exception)。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(System.String,System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="object" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="DomainException.cs" Line="31">在成员 'ObjectNotExistException.ObjectNotExistException(string, object)' 中，考虑将参数名称 'domainObjectId' 中的数据类型标识符“Object”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ObjectRoleMappingStore" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetActorType(System.Type)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="ObjectRoleMappingStore.cs" Line="85">从未使用 'ObjectRoleMappingStore.GetActorType(Type)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsRoleDefinition(System.Type)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="ObjectRoleMappingStore.cs" Line="63">从未使用 'ObjectRoleMappingStore.IsRoleDefinition(Type)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ResolveObjectRoleTypeMappings(System.Reflection.Assembly)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotRaiseReservedExceptionTypes" Category="Microsoft.Usage" CheckId="CA2201" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Name="TooGeneric" Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="ObjectRoleMappingStore.cs" Line="47">'ObjectRoleMappingStore.ResolveObjectRoleTypeMappings(Assembly)' 创建类型为 'Exception' 的异常，该异常类型不够具体，不应由用户代码引发。如有可能引发此异常实例，请使用其他异常类型。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="ObjectRoleMappingStore.cs" Line="35">在外部可见方法 'ObjectRoleMappingStore.ResolveObjectRoleTypeMappings(Assembly)' 中，请在使用参数“assembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RemoveObjectFailedException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'RemoveObjectFailedException': protected RemoveObjectFailedException(SerializationInfo, StreamingContext)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'RemoveObjectFailedException': public RemoveObjectFailedException()。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'RemoveObjectFailedException': public RemoveObjectFailedException(String)。</Issue>
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'RemoveObjectFailedException': public RemoveObjectFailedException(String, Exception)。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(System.String,System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="object" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="DomainException.cs" Line="39">在成员 'RemoveObjectFailedException.RemoveObjectFailedException(string, object)' 中，考虑将参数名称 'domainObjectId' 中的数据类型标识符“Object”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Repository" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="StaticHolderTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1053" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Name="CSharp2_0" Certainty="90" Level="Error">由于类型 'Repository' 仅包含“static”成员，因此将它标记为“static”可阻止编译器添加默认公共构造函数。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Find`1(Domain.Seedwork.DomainModel.FindObjectsEvent`1&lt;!!0&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="Repository.cs" Line="82">考虑将 'Repository.Find&lt;TObject&gt;(FindObjectsEvent&lt;TObject&gt;)' 中参数 'findObjectsEvent' 的类型从 'FindObjectsEvent&lt;TObject&gt;' 改为其基类型 'DomainEvent'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="Repository.cs" Line="82">更改 'Repository.Find&lt;TObject&gt;(FindObjectsEvent&lt;TObject&gt;)' 中的 'List&lt;TObject&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="Repository.cs" Line="84">在外部可见方法 'Repository.Find&lt;TObject&gt;(FindObjectsEvent&lt;TObject&gt;)' 中，请在使用参数“findObjectsEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Remove`2(!!1)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="GenericMethodsShouldProvideTypeParameter" Category="Microsoft.Design" CheckId="CA1004" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="Repository.cs" Line="55">考虑使用 'Repository.Remove&lt;TObject, TObjectId&gt;(TObjectId)' 在任何对它的调用中都不需要显式类型参数 'TObject' 的设计。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Role`2" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AbstractTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1012" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="CriticalWarning">将 'Role&lt;TActor, TRoleId&gt;' 中所有公共构造函数的可访问性改为 protected。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="Role`3" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AbstractTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1012" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="CriticalWarning">将 'Role&lt;TActor, TRoleId, TRoleState&gt;' 中所有公共构造函数的可访问性改为 protected。</Issue>
          </Message>
          <Message TypeName="AvoidExcessiveParametersOnGenericTypes" Category="Microsoft.Design" CheckId="CA1005" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Certainty="85" Level="Error">考虑使用 'Role&lt;TActor, TRoleId, TRoleState&gt;' 带有的类型参数不超过两个的设计。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="UniqueId" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Guid)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\DomainModel" File="UniqueId.cs" Line="14">方法 'UniqueId.UniqueId(Guid)' 将“UniqueId”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ValidationErrorItem" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Parameters" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning">通过移除属性 setter 将 'ValidationErrorItem.Parameters' 更改为只读。</Issue>
            </Message>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">更改 'ValidationErrorItem.Parameters' 中的 'List&lt;object&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="Domain.Seedwork.PersistenceModel">
       <Types>
        <Type Name="IObjectCollection`2" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Get(!1)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Get" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'IObjectCollection&lt;TObject, TObjectId&gt;.Get(TObjectId)'，使它不再与保留的语言关键字“Get”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ObjectCollection`2" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AbstractTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1012" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="CriticalWarning">将 'ObjectCollection&lt;TObject, TObjectId&gt;' 中所有公共构造函数的可访问性改为 protected。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#GetTrackingObjects()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="141">如果可行，请将 'ObjectCollection&lt;TObject, TObjectId&gt;.GetTrackingObjects()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetTrackingProperties(!0)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="273">从未使用 'ObjectCollection&lt;TObject, TObjectId&gt;.GetTrackingProperties(TObject)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Handle(Domain.Seedwork.DomainModel.AddObjectEvent`1&lt;!0&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="41">在外部可见方法 'ObjectCollection&lt;TObject, TObjectId&gt;.Handle(AddObjectEvent&lt;TObject&gt;)' 中，请在使用参数“evnt”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Handle(Domain.Seedwork.DomainModel.GetObjectEvent`2&lt;!0,!1&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="37">在外部可见方法 'ObjectCollection&lt;TObject, TObjectId&gt;.Handle(GetObjectEvent&lt;TObject, TObjectId&gt;)' 中，请在使用参数“evnt”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Handle(Domain.Seedwork.DomainModel.RemoveObjectEvent`1&lt;!0&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="45">在外部可见方法 'ObjectCollection&lt;TObject, TObjectId&gt;.Handle(RemoveObjectEvent&lt;TObject&gt;)' 中，请在使用参数“evnt”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PersistModifiedObjects(System.Collections.Generic.List`1&lt;!0&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="157">更改 'ObjectCollection&lt;TObject, TObjectId&gt;.PersistModifiedObjects(List&lt;TObject&gt;)' 中的 'List&lt;TObject&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PersistNewObjects(System.Collections.Generic.List`1&lt;!0&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="154">更改 'ObjectCollection&lt;TObject, TObjectId&gt;.PersistNewObjects(List&lt;TObject&gt;)' 中的 'List&lt;TObject&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PersistRemovedObjects(System.Collections.Generic.List`1&lt;!0&gt;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="ObjectCollection.cs" Line="160">更改 'ObjectCollection&lt;TObject, TObjectId&gt;.PersistRemovedObjects(List&lt;TObject&gt;)' 中的 'List&lt;TObject&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UnitOfWork" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'UnitOfWork' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="UnitOfWork.cs" Line="49">修改 'UnitOfWork.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
             <Issue Name="DisposeSignature" Certainty="95" Level="Error" Path="E:\MyCode\MyCommonLibrary\Domain.Seedwork\PersistenceModel" File="UnitOfWork.cs" Line="49">确保将 'UnitOfWork.Dispose()' 声明为 public 和 sealed。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PersistableCollections" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2011-11-09 02:47:47Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">更改 'UnitOfWork.PersistableCollections' 中的 'List&lt;IPersistableCollection&gt;' 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="AbstractTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1012">
   <Name>抽象类型不应具有构造函数</Name>
   <Description>抽象类型的公共构造函数没有意义，因为您无法创建抽象类型的实例。</Description>
   <Resolution Name="Default">将 {0} 中所有公共构造函数的可访问性改为 protected。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182126(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidEmptyInterfaces" Category="Microsoft.Design" CheckId="CA1040">
   <Name>避免使用空接口</Name>
   <Description>接口应包含指定一组行为的成员。若要对类进行标记，请使用特性而不是空接口。</Description>
   <Resolution Name="Default">定义一个自定义特性来替换 {0}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182128(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Warning</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidExcessiveParametersOnGenericTypes" Category="Microsoft.Design" CheckId="CA1005">
   <Name>避免泛型类型的参数过多</Name>
   <Description>避免泛型类型的类型参数在两个以上，因为如果类型的参数列表很长，用户将难以理解其中各项参数的含义。</Description>
   <Resolution Name="Default">考虑使用 {0} 带有的类型参数不超过两个的设计。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182129(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="85">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidNamespacesWithFewTypes" Category="Microsoft.Design" CheckId="CA1020">
   <Name>避免使用类型极少的命名空间</Name>
   <Description>命名空间一般应具有五个以上的类型。</Description>
   <Resolution Name="Default">考虑将“{0}”中定义的类型与另一个命名空间合并。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182130(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Warning</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813">
   <Name>避免使用未密封的特性</Name>
   <Description>密封特性类型可以提高性能。在对自定义特性进行反射期间，密封特性类型可以提高性能。</Description>
   <Resolution Name="Default">如有可能，请密封 {0}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182267(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227">
   <Name>集合属性应为只读</Name>
   <Description>返回集合的属性应为只读，以确保用户无法完全替换后备存储。用户通过对集合调用相关方法仍然可以修改集合的内容。请注意，XmlSerializer 类对反序列化只读集合具有专门的支持。有关详细信息，请参见 XmlSerializer 概述。</Description>
   <Resolution Name="Default">通过移除属性 setter 将 {0} 更改为只读。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182327(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011">
   <Name>考虑将基类型作为参数传递</Name>
   <Description>如果仅使用参数的基类中的方法和属性，则将基类型用作方法的参数可以提高这些方法的重复利用率。例如，如果仅调用 Stream.Read()，则使用 Stream 而不是 FileStream 作为参数，这可以使该方法适用于所有类型的流，而不仅仅适用于 File 流。</Description>
   <Resolution Name="Default">考虑将 {1} 中参数 {0} 的类型从 {2} 改为其基类型 {3}。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/3hk32yyz(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002">
   <Name>不要公开泛型列表</Name>
   <Description>不要在对象模型中公开 List&lt;T&gt;。应使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;。List&lt;T&gt; 应通过实现来使用，而不是在对象模型 API 中使用。List&lt;T&gt; 针对性能进行了优化，但代价是需要长期进行版本管理。例如，如果将 List&lt;T&gt; 返回到客户端代码，您将无法再在客户端代码修改集合时收到通知。</Description>
   <Resolution Name="Default">更改 {1} 中的 {0} 以使用 Collection&lt;T&gt;、ReadOnlyCollection&lt;T&gt; 或 KeyedCollection&lt;K,V&gt;</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182142(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotRaiseReservedExceptionTypes" Category="Microsoft.Usage" CheckId="CA2201">
   <Name>不要引发保留的异常类型</Name>
   <Description>用户代码不应创建和引发某些类型的异常，即属于运行时保留的异常类型或太通用的异常类型。太通用的异常类型包括 Exception、SystemException 和 ApplicationException。运行时保留的异常类型包括 ThreadAbortException、OutOfMemoryException、ExecutionEngineException 和 IndexOutOfRangeException。</Description>
   <Resolution Name="TooGeneric">{0} 创建类型为 {1} 的异常，该异常类型不够具体，不应由用户代码引发。如有可能引发此异常实例，请使用其他异常类型。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182338(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="usagerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="GenericMethodsShouldProvideTypeParameter" Category="Microsoft.Design" CheckId="CA1004">
   <Name>泛型方法应提供类型参数</Name>
   <Description>以下方法令人难以理解，在这些方法中，类型参数无法从参数中推理出来，因此必须在方法调用中定义。如果方法带有类型化为泛型方法类型参数的形参，则这些方法支持推理；如果方法没有类型化为泛型方法类型参数的形参，则这些方法不支持推理。</Description>
   <Resolution Name="Default">考虑使用 {0} 在任何对它的调用中都不需要显式类型参数 {1} 的设计。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182150(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720">
   <Name>标识符不应包含类型名称</Name>
   <Description>应避免在参数和成员中使用特定于某一种语言的类型名称，避免在参数中使用数据类型标识符。类型名对于所有开发人员来说可能不够直观。建议选用通用名称，如“value”。如果不足以区分，应确保采用 .NET Framework 库中定义的类型名，并完全避免采用特定于某一种语言的类型名称。例如，特定于 C# 的类型名有“float”(如果通用名称不足以区分，则使用“Single”)和“ulong”(如果通用名称不足以区分，则使用“UInt64”)等等。</Description>
   <Resolution Name="LanguageIndependentMemberParameter">在成员 {0} 中，考虑将参数名称 {2} 中的数据类型标识符“{1}”替换为一个更通用的词条，如“value”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb531486(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="namingrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716">
   <Name>标识符不应与关键字冲突</Name>
   <Description>应避免使用与保留的语言关键字冲突的标识符。如果使用保留的语言关键字作为标识符，则会使其他语言的使用者很难使用您的 API。</Description>
   <Resolution Name="Member">重命名虚拟/接口成员 {0}，使它不再与保留的语言关键字“{1}”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Resolution>
   <Resolution Name="Type">重命名类型 {0}，使它不再与保留的语言关键字“{1}”冲突。如果使用保留的关键字作为类型的名称，则会使其他语言的使用者很难使用该类型。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182248(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063">
   <Name>正确实现 IDisposable</Name>
   <Description>所有 IDisposable 类型都应正确实现 Dispose 模式。</Description>
   <Resolution Name="DisposeImplementation">修改 {0}，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Resolution>
   <Resolution Name="DisposeSignature">确保将 {0} 声明为 public 和 sealed。</Resolution>
   <Resolution Name="ProvideDisposeBool">对 {0} 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms244737(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementISerializableCorrectly" Category="Microsoft.Usage" CheckId="CA2240">
   <Name>正确实现 ISerializable</Name>
   <Description>如果可将类型赋给 ISerializable，则它应实现 GetObjectData。对于非密封类型，其派生类型应可以调用和重写 GetObjectData 方法。</Description>
   <Resolution Name="Default">向类型 {0} 中添加对 GetObjectData 的实现。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182342(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="60">Error</MessageLevel>
   <File Name="usagerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032">
   <Name>实现标准异常构造函数</Name>
   <Description>正确实现一个自定义异常需要多个构造函数。缺少构造函数会使您的异常在某些情况下无法使用。例如，在 XML Web services 中处理异常需要序列化构造函数。</Description>
   <Resolution Name="MissingConstructor">将下列构造函数添加到 {0}: {1}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182151(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208">
   <Name>正确实例化参数异常</Name>
   <Description>传递给 ArgumentException 及其派生类型的构造函数的字符串参数应该是正确的。与 ArgumentException 相比，派生自 ArgumentException 的类型在 message 和 paramName 参数方面具有不一致的构造函数重载。</Description>
   <Resolution Name="IncorrectParameterName">方法 {0} 将“{1}”作为参数 {2} 传递给构造函数 {3}。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182347(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="usagerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822">
   <Name>将成员标记为 static</Name>
   <Description>不访问实例数据或调用实例方法的方法可标记为 Static (在 Visual Basic 中为 Shared)。这样，编译器会向这些成员发出非虚拟调用站点，以防止在运行时对每个调用进行旨在确保当前对象指针为非 null 的检查。这样可以使对性能比较敏感的代码获得显著的性能提升。在某些情况下，无法访问当前对象实例表明存在正确性问题。</Description>
   <Resolution Name="Default">从未使用 {0} 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms245046(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="StaticHolderTypesShouldNotHaveConstructors" Category="Microsoft.Design" CheckId="CA1053">
   <Name>静态容器类型不应具有构造函数</Name>
   <Description>不需要创建只定义静态成员的类型的实例。如果没有指定构造函数，许多编译器都会自动添加公共的默认构造函数。为了避免出现这种情况，可能需要添加一个空的私有构造函数。</Description>
   <Resolution Name="CSharp2_0">由于类型 {0} 仅包含“static”成员，因此将它标记为“static”可阻止编译器添加默认公共构造函数。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182169(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024">
   <Name>在适用处使用属性</Name>
   <Description>在大多数情况下，应使用属性而不是 Get/Set 方法。在下列情况下，方法比属性更可取: 第一，执行的是转换操作，操作开销大或具有显著的副作用；第二，执行的顺序很重要；第三，连续两次调用成员得到的结果不同；第四，静态成员却返回了可变的值；第五，成员返回了数组。</Description>
   <Resolution Name="Default">如果可行，请将 {0} 改为属性。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182181(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="designrules.dll" Version="10.0.0.0" />
  </Rule>
  <Rule TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062">
   <Name>验证公共方法的参数</Name>
   <Description>应检查传递给外部可见方法的所有引用参数是否为 Null (在 VB 中为 Nothing)。如果适用，在参数为 null 时，引发 System.ArgumentNullException。</Description>
   <Resolution Name="Default">在外部可见方法 {0} 中，请在使用参数“{1}”之前先对其进行验证。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182182(VS.100).aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="10.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">类别</String>
  <String Key="Certainty">确定性</String>
  <String Key="CollapseAll">全部折叠</String>
  <String Key="CheckId">检查 ID</String>
  <String Key="Error">错误</String>
  <String Key="Errors">错误</String>
  <String Key="ExpandAll">全部展开</String>
  <String Key="Help">帮助</String>
  <String Key="Line">行</String>
  <String Key="Messages">消息</String>
  <String Key="LocationNotStoredInPdb">[位置未存储在 Pdb 中]</String>
  <String Key="Project">项目</String>
  <String Key="Resolution">解析</String>
  <String Key="Rule">规则</String>
  <String Key="RuleFile">规则文件</String>
  <String Key="RuleDescription">规则说明</String>
  <String Key="Source">源</String>
  <String Key="Status">状态</String>
  <String Key="Target">目标</String>
  <String Key="Warning">警告</String>
  <String Key="Warnings">警告</String>
  <String Key="ReportTitle">代码分析报告</String>
 </Localized>
</FxCopReport>
